{
  "version": 3,
  "sources": ["../../../../node_modules/vue-blox-expressions/dist/vue-blox-expressions.es.js"],
  "sourcesContent": ["var v = Object.defineProperty;\nvar b = (r, t, e) => t in r ? v(r, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : r[t] = e;\nvar g = (r, t, e) => (b(r, typeof t != \"symbol\" ? t + \"\" : t, e), e);\nimport { BloxError as i } from \"vue-blox\";\nimport { toRaw as m } from \"vue\";\nclass _ {\n  constructor(t) {\n    g(this, \"parser\");\n    t.functions.internal_invokeFunctions = (...e) => () => {\n      for (let o = 0; o < e.length; o += 1) {\n        const s = e[o];\n        s();\n      }\n    }, this.parser = t;\n  }\n  run(t, e, o, s, d) {\n    const l = \"compute:\";\n    if (!t.startsWith(l))\n      return;\n    const c = t.substring(l.length, t.length);\n    if (c.length === 0)\n      throw new i(\n        \"Compute parsing failed.\",\n        \"The value for the prop name for compute must be a string with length > 0.\",\n        {\n          key: t,\n          value: e\n        }\n      );\n    const u = e;\n    if (/^__proto__|prototype|constructor$/.test(u))\n      throw new i(\n        \"Expression parsing failed.\",\n        `The call to parser.evaluate() for value ${e} was aborted because prototype access was detected.`,\n        void 0\n      );\n    const p = {};\n    Object.assign(p, m(o));\n    try {\n      const n = this.parser.evaluate(u, p);\n      s(c, n);\n    } catch (n) {\n      throw new i(\n        \"Expression parsing failed.\",\n        `The call to parser.evaluate() for value ${e} threw the error: ${n}`,\n        void 0\n      );\n    }\n  }\n}\nfunction S({ parser: r }) {\n  return new _(r);\n}\nclass x {\n  constructor(t) {\n    g(this, \"parser\");\n    t.functions.internal_invokeFunctions = (...e) => () => {\n      for (let o = 0; o < e.length; o += 1) {\n        const s = e[o];\n        s();\n      }\n    }, this.parser = t;\n  }\n  run(t, e, o, s, d) {\n    const l = \"on:\";\n    if (!t.startsWith(l))\n      return;\n    const c = t.substring(l.length, t.length);\n    if (c.length === 0)\n      throw new i(\n        \"Emit parsing failed.\",\n        \"The value for the prop name for emit must be a string with length > 0.\",\n        {\n          key: t,\n          value: e\n        }\n      );\n    const u = (f) => {\n      let a = f.split(/[^a-zA-Z0-9]/), w = a[0].toLowerCase();\n      for (let h = 1; h < a.length; h++)\n        w += a[h].charAt(0).toUpperCase() + a[h].slice(1).toLowerCase();\n      return w;\n    }, p = e;\n    if (/^__proto__|prototype|constructor$/.test(p))\n      throw new i(\n        \"Expression parsing failed.\",\n        `The call to parser.evaluate() for value ${e} was aborted because prototype access was detected.`,\n        void 0\n      );\n    const n = {};\n    Object.assign(n, m(o)), s(u(`on_${c}`), (...f) => {\n      Object.assign(n, f);\n      try {\n        this.parser.evaluate(p, n);\n      } catch (a) {\n        throw new i(\n          \"Expression parsing failed.\",\n          `The call to parser.evaluate() for value ${e} threw the error: ${a}`,\n          void 0\n        );\n      }\n    });\n  }\n}\nfunction T({ parser: r }) {\n  return new x(r);\n}\nexport {\n  _ as BloxPluginCompute,\n  x as BloxPluginEmit,\n  S as getPluginCompute,\n  T as getPluginEmit\n};\n"],
  "mappings": "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",
  "names": []
}
